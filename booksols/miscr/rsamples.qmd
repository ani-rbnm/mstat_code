---
title: R snippets
format: html
---

* *mode* corresponds to data type. For eg. every element of `vector` type have the same mode
* Types of modes:
  - integer
  - numeric(floating point)
  - boolean
  - string
  - complex

* Use `typeof` to get mode
```{r}
typeof(1:10)
typeof(c("a","b"))
```
* Typical use of lists - combine dissimilar data returned by a function
`hist()` is a typical example

```{r}
hn <- hist(Nile)
str(hn)
hn$density
class(hn)
str(1:3)
```
* attributes of a class using the `attributes()` function


```{r}
examsquiz <- read.table("ExamsQuiz.txt", header = FALSE)
class(examsquiz)
head(examsquiz)
lma <- lm(examsquiz[,"V2"] ~ examsquiz[,"V1"])
attributes(lma)
```
* can access attributes by abbreviation of the attribute names as long as there is no conflict


```{r}
lma$coe
```
### Vectors

* `seq()` has `from`, `to`, `by`
* `rep()` has `times` and `each`

```{r}
seq(from = 1.1, to = 2, length.out = 11)
```
* Some vector indexing examples

```{r}
# all but the last element
v <- 1:10
v[-length(v)]
```
* many built-in functions such as `>`, `+` etc are *vectorised*.
* if a function uses vectorised functions, the function itself is vectorised
  - vectorised functions have performance advantage
  - if a function uses if block, they are not vectorised since `if` does not work on vectors. Use `ifelse()` instead.

* How do we **convert a vector into a matrix** ? Use `sapply()` and use a function that returns a vector. Each vector returned then would correspond to a column

```{r}
sapply(1:8, \(x) c(x, x^2)) # lambda function
```
* use of `NULL` - When we want to incrementally build a vector. Initialising with `NULL` helps use predeclare variable without any element in it.
- This is different from `NA`. This is a legitimate but unknown value so if initialised with it, `NA` would be the first element.

```{r}
x <- NULL
for (i in seq_len(3)) x <- c(x,i + 3)
x
y <- NA
for (i in seq_len(3)) y <- c(y,i + 3)
y
```
* filtering

```{r}
z <- 2:11
z[z^2 > 8 & z^2 < 80]
```
* difference between ordinary filtering and `subset()` : subset ignores `NA`

```{r}
x <- c(11,2:6, NA, 21)
x[x > 5]
subset(x, x > 5)
```
* `which()` returns index of succesful search criteria
* `ifelse()` for vectorised if conditions

##### Example: Determining one measure of coorelation between `x` and `y`

```{r}
# function returning 1,-1 depending on if the input v[i+1] > v[i]
findinc <- function(v) {
  v <- v[-1] - v[-length(v)]
  ifelse(v > 0, 1,-1)
}
# correlation = no. of times both x[i + 1] > x[i] and y[i + 1] > y[i]
calcCorr <- function(x,y) {
  l <- lapply(list(x,y), findinc)
  mean(ifelse(l[[1]]==l[[2]], 1,0))
} 
x <- c(5,12,13,3,6, 0,1,15,16, 8,88)
y <- c(4,2,3,23,6,10,11,12,6,3,2)
calcCorr(x,y)
```
* following is an example of the same using `diff()` and `sign()` functions

```{r}
calcCorr2 <- function(x,y) {
  mean(sign(diff(x)) == sign(diff(y)))
}
calcCorr2(x,y)
```
##### Example: filtering rows of df based on values in column


```{r}
aba_df <- read.csv("Abalone.data", header = FALSE, as.is = TRUE)
colnames(aba_df) <- c("Gender", "Length", "Diameter","Height", "WholeWt", "ShuckedWt", "ViscWt", "ShellWt", "Rings")

# Creating list
grps <- list()
for (gen in c("M","F")) grps[[gen]] <- which(aba_df[,"Gender"] == gen)
abam <- aba_df[grps$M,]
abaf <- aba_df[grps$F,]
plot(abam$Diameter ~ abam$Length, pch = 16)
points(abaf$Diameter ~ abaf$Length, pch = "x", col="blue")
```

### Matrices

* `row()` returns the row value of each element in a vectorised function. Same with `col()`

Following example makes a covariance matrix with same covariance $\rho$
```{r}
makeCov <- function(rho, n) {
  mcov <- matrix(nrow = n, ncol = n)
  mcov <- ifelse(row(mcov) == col(mcov), 1, rho)
  mcov
}
makeCov(0.23, 5)
```
* `apply()` returns a vector. 
Below function mimics what `colMeans()` does


```{r}
z <- matrix(1:6, nrow = 3)
apply(z, MARGIN = 2, FUN = mean)
colMeans(z)
```
