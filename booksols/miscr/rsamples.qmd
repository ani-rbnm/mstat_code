,--
title: R snippets
format: html
---

* *mode* corresponds to data type. For eg. every element of `vector` type have the same mode
* Types of modes:
  - integer
  - numeric(floating point)
  - boolean
  - string
  - complex

* Use `typeof` to get mode
```{r}
typeof(1:10)
typeof(c("a","b"))
```
* Typical use of lists - combine dissimilar data returned by a function
`hist()` is a typical example

```{r}
hn <- hist(Nile)
str(hn)
hn$density
class(hn)
str(1:3)
```
* attributes of a class using the `attributes()` function


```{r}
examsquiz <- read.table("ExamsQuiz.txt", header = FALSE)
class(examsquiz)
head(examsquiz)
lma <- lm(examsquiz[,"V2"] ~ examsquiz[,"V1"])
attributes(lma)
```
* can access attributes by abbreviation of the attribute names as long as there is no conflict

```{r}
lma$coe
```
### Vectors

* `seq()` has `from`, `to`, `by`
* `rep()` has `times` and `each`

```{r}
seq(from = 1.1, to = 2, length.out = 11)
```
* Some vector indexing examples

```{r}
# all but the last element
v <- 1:10
v[-length(v)]
```
* many built-in functions such as `>`, `+` etc are *vectorised*.
* if a function uses vectorised functions, the function itself is vectorised
  - vectorised functions have performance advantage
  - if a function uses if block, they are not vectorised since `if` does not work on vectors. Use `ifelse()` instead.

* How do we **convert a vector into a matrix** ? Use `sapply()` and use a function that returns a vector. Each vector returned then would correspond to a column

```{r}
sapply(1:8, function(x) c(x, x^2)) # lambda function
```
* use of `NULL` - When we want to incrementally build a vector. Initialising with `NULL` helps use predeclare variable without any element in it.
- This is different from `NA`. This is a legitimate but unknown value so if initialised with it, `NA` would be the first element.

```{r}
x <- NULL
for (i in seq_len(3)) x <- c(x,i + 3)
x
y <- NA
for (i in seq_len(3)) y <- c(y,i + 3)
y
```
* filtering

```{r}
z <- 2:11
z[z^2 > 8 & z^2 < 80]
```
* difference between ordinary filtering and `subset()` : subset ignores `NA`

```{r}
x <- c(11,2:6, NA, 21)
x[x > 5]
subset(x, x > 5)
```
* `which()` returns index of succesful search criteria
* `ifelse()` for vectorised if conditions

##### Example: Determining one measure of coorelation between `x` and `y`

```{r}
# function returning 1,-1 depending on if the input v[i+1] > v[i]
findinc <- function(v) {
  v <- v[-1] - v[-length(v)]
  ifelse(v > 0, 1,-1)
}
# correlation = no. of times both x[i + 1] > x[i] and y[i + 1] > y[i]
calcCorr <- function(x,y) {
  l <- lapply(list(x,y), findinc)
  mean(ifelse(l[[1]]==l[[2]], 1,0))
} 
x <- c(5,12,13,3,6, 0,1,15,16, 8,88)
y <- c(4,2,3,23,6,10,11,12,6,3,2)
calcCorr(x,y)
```
* following is an example of the same using `diff()` and `sign()` functions

```{r}
calcCorr2 <- function(x,y) {
  mean(sign(diff(x)) == sign(diff(y)))
}
calcCorr2(x,y)
```
##### Example: filtering rows of df based on values in column


```{r}
aba_df <- read.csv("Abalone.data", header = FALSE, as.is = TRUE)
colnames(aba_df) <- c("Gender", "Length", "Diameter","Height", "WholeWt", "ShuckedWt", "ViscWt", "ShellWt", "Rings")

# Creating list
grps <- list()
for (gen in c("M","F")) grps[[gen]] <- which(aba_df[,"Gender"] == gen)
abam <- aba_df[grps$M,]
abaf <- aba_df[grps$F,]
plot(abam$Diameter ~ abam$Length, pch = 16)
points(abaf$Diameter ~ abaf$Length, pch = "x", col="blue")
```

### Matrices

* `row()` returns the row value of each element in a vectorised function. Same with `col()`

Following example makes a covariance matrix with same covariance $\rho$
```{r}
makeCov <- function(rho, n) {
  mcov <- matrix(nrow = n, ncol = n)
  mcov <- ifelse(row(mcov) == col(mcov), 1, rho)
  mcov
}
makeCov(0.23, 5)
```
* `apply()` returns a vector. 
Below function mimics what `colMeans()` does

```{r}
z <- matrix(1:6, nrow = 3)
apply(z, MARGIN = 2, FUN = mean)
colMeans(z)
class(z)
```
* using `rbind()` and `cbind()` to add vectors to matrices

```{r}
m <- matrix(1:9, nrow = 3)
# recycling occurs here
rbind(m, 21)
```
* matrix is a bit more than a vector as suggested by the `nrow()`, `dim()`, `ncol()`

```{r}
m <- matrix(1:9, nrow = 3)
class(m)
nrow(m)
ncol(m)
dim(m)
attributes(m)

```

* use `drop = F` to disable dimensionality reduction

### Lists

* what is the classname and attributes of list

```{r}
lst <- list(name="Joe", salary = 55000, union = T)
class(lst)
attributes(lst)
```
* can create list using `vector(mode="list")`

```{r}
z <- vector(mode = "list")
class(z)
```
* concatenating lists

```{r}
cl <- c(list("Joe", 55000, T), list(5))
```
* concatenating values to element of a list

```{r}
lst <- list()
# When the element is non-existent
lst[["first"]] <- c(lst[["first"]], 1)
lst
# When element is existent
lst[["first"]] <- c(lst[["first"]], 2)
lst
```
* `unlist()` to flatten list into vector

```{r}
lst <- list(name = "Joe", salary = 55000, union = T)
v <- unlist(lst)
v
class(v)
```
##### Example: creating a list containing indices of original vector corresponding to the tag of the list

```{r}
g <- c("M", "M", "F", "F", "M", "F", "F", "M", "I")
lidx <- lapply(c("M", "F", "I"), \(gender)which(g == gender))
names(lidx) <- c("M", "F", "I")
lidx
```
### Dataframes

* Accessing elements: we can access elements of a dataframe using the 3 methods of lists, but also 
using the matrix element access methods

```{r}
d <- data.frame(kids = c("Jack", "Jill", "Morgan"), ages = c(12,10, 11), gender = c("M", "F", "M"))
class(d)
attributes(d)
d[,"ages"]
d[,2]
# selection example: "kids" column where gender is a certain value
# d[d[,"gender"] == "M", "kids", drop = F]
d[d$gender == "M", "kids", drop = F]
colnames(d) <- c("k", "a", "g")
d
```
* dealing with NA values

```{r}
d <- data.frame(kids = c("Jack", "Jill", "Morgan"), ages = c(12,10, 11), gender = c(NA, "F", "M"))
any(is.na(d[d$gender == "M", "kids"]))
d[!is.na(d$gender) & d$gender == "M", "kids"]
# subset() would automatically ignore the NA values
subset(d, gender=="M")$kids

```
* `complete.cases(d)` for a T/F vector, with T being for those will none of the col value = NA

### Factors

* main functions: `tapply()`, `split()` , `by()` and `ave()`

**`split()` can be applied on the whole dataframe as opposed to a single column like with `tapply()`**
```{r}
ages <- c(25, 26, 55, 37, 21, 42)
affils <- c("R", "D", "D", "R", "U", "D")
tapply(ages, affils, mean)
ave(ages, affils, FUN = max )
split(ages, affils)
```
##### Example - `tapply()` using multi-column categories
* key info: the group by columns must be passed as a `list`

```{r}
d <- data.frame(list(
  gender = c("M", "M", "F", "M", "F", "F"),
  age = c(47, 59, 21,32, 33, 24), income = c(55000, 88000, 32450, 76500, 123000, 45650)
))
d
d$over25 <- ifelse(d$age > 25, 1,0)
d
tapply(d$income, list(d$gender, d$over25), mean)
```
* can use *matrix like* references for both data frames and tables

```{r}
ct <- read.table("ct.dat", header = T)
ct
cttab <- table(ct)
cttab
cttab[,2]
cttab/sum(cttab)
```
* `addmargins()` function gives the marginal sum both rowwise and columnwise

```{r}
addmargins(cttab)
```
* Example: getting a subset of a table. Key information is **calling `do.call()` on the `"["` 
which is a built-in function. `func[subset1, subset2]` is internally called as `"["(subset1, subset2)`. 
We imitate this call through the `do.call("[", list(subset1,subset2))`. 

```{r}
subnames <- list(Vote.for.X = c("Yes", "No"),
Vote.for.X.Last.Time = c("No", "Yes")
)
# tblarray <- unclass(cttab)
tblarray
# dcargs <- list(tblarray)
dcargs <- list(cttab)
ndims <- length(subnames)

for (i in seq_len(ndims)) {
  dcargs[[i + 1]] <- subnames[[i]]
}
dcargs
subarray <- do.call("[", dcargs)
class(subarray)
attributes(subarray)
# dims <- lapply(subnames, length)
# subtbl <- array(subarray, list(2,2), subnames)
# class(subtbl) <- "table"
str(subtbl)

```

