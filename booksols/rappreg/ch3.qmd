---
title: R companion to applied reg, ch3 - Exploring and Transforming data
Date: 2025/10/26
format: html
---
* Plotting needed at 3 stages:
  - EDA (term courtesy of Tukey in 1977): To get a general idea of the outliers, odd and interesting features.
  - checking model fit
  - presenting model to others

```{r}
#| message: false
library("car")
Prestige[sample(nrow(Prestige), 10),]
```
#### Common Single column plots

Useful to understand response variable during EDA or residual analysis 
during model fitting

* Histogram: default bins vs *Freedman & Diaconis(1981)* method

```{r}
hist(Prestige$income)
hist(Prestige$income, breaks = "FD" )
box()
```
* printing all parameters of a function

```{r}
args("plot.default")
```
* `stem.leaf()` function in `aplpack` package for pretty-printed histograms

```{r}
library("aplpack")
sl <- stem.leaf(Prestige$income)
stem(Prestige$income)
```
* density estimation with the `density()` function

  - density estimate is overlayed on a *density histogram*. In a density histogram, 
    bin size is kept variable so that the area of a column is the probability of the bin
    We plot this using `freq=F`
  
  - `density()` function uses fixed bandwidth for its calculation


```{r}
hist(Prestige$income, freq=F, breaks="FD")
rug(Prestige$income)
lines(density(Prestige$income, from=0), lwd=2, lty="dashed")
legend("topright", legend="density", lty = "dashed", lwd = 2, inset=0.02)
box()
```
* `qqnorm()` for QQ plot against a reference normal distribution

overlay qqplot for another variable onto the same plot
  - `plot.it` option
  - overlay using `points()`
```{r}
xExp <- rexp(1000, rate = 1)
xDens <- density(xExp)
# Density plot
# plot(xDens$x, xDens$y, lty="solid", lwd=2, type="l")
qqnorm(xExp, pch=16, ylim = c(-15,15))
qqline(xExp, col="red", pty="dashed", lwd = 2)
yvals <- qqnorm(-rexp(1000, rate = 1), plot.it = F )
points(yvals, pch = 16, col = 2)
```
* `boxplot()` 


```{r}
boxplot(Prestige$income)
```
#### Plots for multiple columns

##### scatterplots
  - spread along the y-axis for a given value of x is the *conditional distribution* 
  of y w.r.t x

*R. D. Cook and Weisberg for general treatment of summary graphs in regression*

```{r}
plot(Prestige$income, Prestige$prestige, xlab="income", ylab="prestige")
```

* plotting with `scatterplot` of the `cars` package


```{r}
scatterplot(Prestige$prestige ~ Prestige$income, data = Prestige, id = list(n=4))
```
This clearly shows linear regression would not be a good fit.

* conditioning on categorical variable

```{r}
str(Prestige)
cols <- ifelse(Prestige$type == "bc", "red", 
  ifelse(Prestige$type == "wc", "green", "blue")
)
plot(Prestige$income, Prestige$prestige, col = cols, lwd = 2, pch = 16)
plot(prestige ~ income, data = Prestige,  col = cols, lwd = 2, pch = 16)
legend("bottomright",  legend=c("bc", "wc", "prof"), pch = 16, col = c("red", "green", "blue"), inset = 0.02)
scatterplot(prestige ~ income | type, data = Prestige, legend = list(coords = "bottomright", inset = 0.1),
  smooth = list(span = 0.9))
```
`span` attribute above represents the percentage of data used for the the `loess` smoothing
logic used.

* discrete value scatterplots - jittering scatterplots

```{r}
head(Vocab, n = 10)
str(Vocab)
plot(Vocab$education, Vocab$vocabulary, main = "(a)", xlab = "education",
ylab = "vocabulary", pch = 1, col = "blue", cex = 0.8)
abline(lm(vocabulary ~ education, data = Vocab), col = "blue", lwd = 2)
plot(jitter(vocabulary, factor = 2) ~ jitter(education, factor = 2),
data = Vocab, cex = 0.01, col = "darkgray")
abline(lm(vocabulary ~ education, data = Vocab), lwd = 2, lty = 2)
loessLine(Vocab$education, Vocab$vocabulary, var=T, smoother.args = list(span = 1/3))
```
Using the `car` package `scatterplot` function

```{r}
scatterplot(vocabulary ~ education , data = Vocab, main = "default plot")
scatterplot(vocabulary ~ education, data = Vocab, main = "Smoothed", 
jitter = list(x = 2, y = 2), cex = 0.01, col = "darkgray", # additing jitter to make the various points to spread out 
  smooth = list(span = 1/3, col.smooth = "black") # smoothing setting for the default loess smoother
)
```
##### Box plots
* Box plots is a good plot to detect relationship between categorical response and predictors

```{r}
boxplot(vocabulary ~ education, data = Vocab)
```
* `Ornstein` dataset: interlocking of companies along with their assets, sector and country

```{r}
str(Ornstein)
boxplot(interlocks ~ nation, data = Ornstein)
```
##### Scatterplot matrix

* `pairs()` function

```{r}
pairs(~ prestige + income + education + women, data = Prestige)
```

### Transforming data

##### log transformation

```{r}

par(mfrow=c(1,2))
densityPlot(~assets, data = Ornstein, main = "(a)")
densityPlot(~log10(assets), data = Ornstein, 
  xlab = expression(log[10] ~ "( assets )"),main = "(b)",
  adjust = 0.65)
```
* Some features:
  - **log transformed data often have 2 to 3 modes**
  - unit increase corresponds to increase in ratio. Helps us make ratio comparisons.
  - log2 might be a natural base since unit increase = 2 times increase
  - where [ log transformation is likely to help ]{style="color: red; font-weight: bold"}
    - strictly positive values with infinite end point
    - range of values > 2 orders of magnitude (> 100)
    - may not be useful otherwise

    This same feature helps in scatterplots too:

using `log` parameter to plot log scale on both x and y axes. We can individually give `x` or `y`
```{r}

plot(infantMortality ~ ppgdp, data = UN, 
xlab = "GDP per capital", 
ylab = "Infant Mortality rate")
plot(infantMortality ~ ppgdp, data = UN,
xlab = "GDP per capita (log scale)", 
ylab = "Infant Mortality rate", log = "xy")

# scatterplot(infantMortality ~ ppgdp, data = UN,
# xlab = "GDP per capita (log scale)",
# ylab = "Infant Mortality rate",
# log = "xy")
```
* linear regression using log transformation

```{r}
lm.model <- lm(log(infantMortality) ~ log(ppgdp), data = UN)
summary(lm.model)
```

regression model: $log(infantMortality)$ = $\beta_0$ + $\beta_1 * log(ppgdp)$ + $\epsilon$

Interpretation: 1% increase in $ppgdp$ leads to a $\beta_1\%$ increase in infantMortality.
  - property used: $(1+x)^n \approx (1+nx)$

#### Power transform

* Box-Cox scaled transform


```{r}
max(Ornstein$interlocks)

func <- function (x, s,t ) {
  message(paste0("value:",x,"::::",s,",",t))
  return(x^2)
}

x <- c("first", "second", "third")
sapply(x,func, s = "AA", t = "BB")

m <- matrix(1:9, nrow = 3)
mymean <- function(vec, st) {
  message(paste0("vec is:", vec,",FOR:", st))
  mean(vec) 
}
apply(m, 2, mymean, st = "AAAA")
ddj("abc")

```

```{r}
animals <- c(rep(c("cow", "sheep", "donkey"), each = 2 ), c("sheep"))
table(animals)
val <- which.max(table(animals))
str(val)
names(val)
```
