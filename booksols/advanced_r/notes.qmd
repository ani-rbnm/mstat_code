---
title: Advanced R
format: 
  html:
    css: styles.css
  pdf:
    include-in-header:
      text: |
        \input{preamble.css}
---

#### Imports
```{r}
## library to inspect objects
library(lobstr)
```
(@) reassignment [does not create]{.warning} new objects.

```{r}
x <- c(1,2,3)
y <- x
obj_addr(x)
obj_addr(y)
ref(x)
ref(y)
```
- Can use either `obj_addr` or `ref`

(@) strict about syntactic names: only [characters]{.key}, [underscore]{.key}, [digits]{.key} and [dots]{.key} are allowed.
Can [only]{.warning} start with [digits]{.warning} or [dot but not followed by a number]{.warning}. 
In order to use [non-syntactic]{.warning} identifiers, use [backticks.]{.warning}
    
```{r}
`_abc` <- 1
`_abc`
`10` <- 15
`10`
```
(@) use `make.names` to convert to valid values. 
    
(@) [copy-on-modify]{.key} objects are copied only when they are modified

    * Once duplicate object was created for y, it is the [single pointer]{.warning} to the new object. So, subsequent
changes [do not create]{.warning} any further objects.
```{r}
x <- c(1,2,3)
cat(tracemem(x), "\n")
y <- x # not here
y[[2]] <- 22
y[[3]] <- 24
untracemem(y)
```
(@) function arguments follow copy-on-modify rule on the passed parameter too.
    
    (@) if the passed parameter is returned back without modification, this would be the same pointer that was passed.

(@) vector objects are created with values in place whereas [lists]{.warning} have [pointers]{.warning} to 
values created separately.

```{r}
vec <- c(1,2,3)
l <- list(1,2,3)

ref(vec)
ref(l)
```
(@) [copy-on-modify for lists]{.key} When lists are modified, they are [shallow copied]{.warning}.
This means that the copied list points to the old objects that were not changed. Only change is to the object that was.

```{r}
l1 <- list(1,2,3)
l2 <- l1
l2[[2]] <- 22
ref(l1, l2)
```
(@) [copy-on-modify for data frames]{.key} Dataframes has one pointer for each column 
    
    (@) [if column is modified]{.key} Vector corresponding to the changed column will be created. 
Then, shallow copy with pointer to the new column vector.
    (@) [row modified]{.key} All vectors copied. Then, shallow copy to the pointers of [each new]{.warning} column.

```{r}
df <- data.frame(a = 1:5, b = 11:15)
df1 <- df
df1[,2] <- df1[,2] * 2
ref(df, df1)
df2 <- df
df2[2,] <- df2[2,1] * 3
ref(df, df2)
```
(@) character vectors do not store values. The point to a [global pool of strings]{.warning}

```{r}
x <- c("a", "a", "abc", "ac")
ref(x, character = TRUE)
```
