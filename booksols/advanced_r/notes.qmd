---
title: Advanced R
format: 
  html:
    css: styles.css
  pdf:
    include-in-header:
      text: |
        \input{preamble.tex}
---


```{r}
#| include: false
knitr::opts_chunk$set(
  results = "markup",
  collapse = TRUE,
  comment = ""
)
```
#### Imports
```{r}
## library to inspect objects
library(lobstr)
```
(@) reassignment [does not create]{.warning} new objects.

```{r}
x <- c(1,2,3)
y <- x
obj_addr(x)
obj_addr(y)
ref(x)
ref(y)
```
- Can use either `obj_addr` or `ref`

(@) strict about syntactic names: only [characters]{.key}, [underscore]{.key}, [digits]{.key} and [dots]{.key} are allowed.
Can [only]{.warning} start with [digits]{.warning} or [dot but not followed by a number]{.warning}. 
In order to use [non-syntactic]{.warning} identifiers, use [backticks.]{.warning}
    
```{r}
`_abc` <- 1
`_abc`
`10` <- 15
`10`
```
(@) use `make.names` to convert to valid values. 
    
(@) [copy-on-modify]{.key} objects are copied only when they are modified

    * Once duplicate object was created for y, it is the [single pointer]{.warning} to the new object. So, subsequent
changes [do not create]{.warning} any further objects. This is an example of [modify-in-place.]{.key}
```{r}
x <- c(1,2,3)
cat(tracemem(x), "\n")
y <- x # not here
y[[2]] <- 22
y[[3]] <- 24
untracemem(y)
```
(@) function arguments follow copy-on-modify rule on the passed parameter too.
    
    * if the passed parameter is returned back without modification, this would be the same pointer that was passed.

(@) vector objects are created with values in place whereas [lists]{.warning} have [pointers]{.warning} to 
values created separately.

```{r}
vec <- c(1,2,3)
l <- list(1,2,3)

ref(vec)
ref(l)
```
(@) [copy-on-modify for lists]{.key} When lists are modified, they are [shallow copied]{.warning}.
This means that the copied list points to the old objects that were not changed. Only change is to the object that was.

```{r}
l1 <- list(1,2,3)
l2 <- l1
l2[[2]] <- 22
ref(l1, l2)
```
(@) [copy-on-modify for data frames]{.key} Dataframes has one pointer for each column 
    
    * [if column is modified,]{.key} Vector corresponding to the changed column will be created. 
Then, shallow copy with pointer to the new column vector.
    * [if row modified,]{.key} All vectors copied. Then, shallow copy to the pointers of [each new]{.warning} column.

```{r}
df <- data.frame(a = 1:5, b = 11:15)
df1 <- df
df1[,2] <- df1[,2] * 2
ref(df, df1)
df2 <- df
df2[2,] <- df2[2,1] * 3
ref(df, df2)
```
(@) character vectors do not store values. They point to a [global pool of strings]{.warning}

```{r}
x <- c("a", "a", "abc", "ac")
ref(x, character = TRUE)
```

(@) [No use declaring an integer vector, since if any member is inadvertently allocated a double value,
it triggers a copy action whereby a double vector is created upcasting each value in the original 
]{.warning}
```{r}
x <- c(1L, 2L, 3L)
tracemem(x)
x[[3]] <- 4
untracemem(x)
```
(@) [Address extensions are not reported by `tracemem`]{.warning}. Note below that `x` was copied when 
we attempted to extend its size to 3.
```{r}
x <- list(1, 2)
tracemem(x)
x[[3]] <- 3
ref(x)
```
[Q. What happens when a list is allocated to itself as a member?]{.question}
shallow-copy of x pointing to the old copy of x. [Note: Ignore the extra copies internally created by
`ref` triggering the two extra `tracemem` messages.]

```{r}
x <- list(1,2)
ref(x)
tracemem(x)
x[[2]] <- x
ref(x)
```
